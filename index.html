
<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ—¥æ–‡ä¸€èµ·å­¸ - å†’éšªé–‹å§‹ï¼</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Kosugi+Maru&family=Varela+Round&display=swap" rel="stylesheet">
  
  <style>
    body {
      font-family: 'Varela Round', 'Kosugi Maru', sans-serif;
      background-color: #fffbeb;
      overflow-x: hidden;
      margin: 0;
    }
    .rounded-font { font-family: 'Kosugi Maru', sans-serif; }
    
    @keyframes bounce-subtle {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    .animate-bounce-subtle { animation: bounce-subtle 2s ease-in-out infinite; }
    
    @keyframes shrink-disappear {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(0); opacity: 0; }
    }
    .animate-shrink { animation: shrink-disappear 0.5s forwards; }

    @keyframes scale-up {
      0% { transform: scale(0.8); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    .animate-scale-up { animation: scale-up 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }

    @keyframes wiggle {
      0%, 100% { transform: rotate(-3deg); }
      50% { transform: rotate(3deg); }
    }
    .animate-wiggle { animation: wiggle 0.5s ease-in-out infinite; }

    .perspective-1000 { perspective: 1000px; }
    .preserve-3d { transform-style: preserve-3d; }
    .backface-hidden { backface-visibility: hidden; -webkit-backface-visibility: hidden; }
    .rotate-y-180 { transform: rotateY(180deg); }

    .pencil-cursor {
      cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 24 24' fill='%230284c7' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z'></path></svg>") 0 22, crosshair;
    }
  </style>

  <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@19.0.0",
    "react-dom": "https://esm.sh/react-dom@19.0.0",
    "react-dom/client": "https://esm.sh/react-dom@19.0.0/client",
    "@google/genai": "https://esm.sh/@google/genai@1.40.0",
    "react/": "https://esm.sh/react@^19.2.4/"
  }
}
</script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    import React, { useState, useEffect, useRef, useMemo } from 'react';
    import { createRoot } from 'react-dom/client';
    import { GoogleGenAI, Modality, Type } from "@google/genai";

    const LOADING_MESSAGES = [
      "è€å¸«æ­£åœ¨æˆ´çœ¼é¡çœ‹ä½ çš„å­—...",
      "æ­£åœ¨æ¯”å°ä½ çš„è²éŸ³èˆ‡æ—¥æœ¬è²å„ª...",
      "å°ç²¾éˆæ­£åœ¨åŠªåŠ›æ‰¹æ”¹ä¸­...",
      "å¤ªæ£’äº†ï¼Œå†ç­‰ä¸€ä¸‹ä¸‹...",
      "æ­£åœ¨åˆ†æä½ çš„ç­†åŠƒé †åº...",
      "é€™ç™¼éŸ³å¾ˆæœ‰æ½›åŠ›å–”ï¼Œå¯©æ ¸ä¸­...",
      "æ­£åœ¨æŠŠä½ çš„ç­”æ¡ˆå¯„çµ¦æ—¥æœ¬è€å¸«..."
    ];

    const HIRAGANA_A_COLUMN = [
      { char: 'ã‚', strokeImg: 'https://raw.githubusercontent.com/nihow79207-wang/japanese-assets/main/ã‚.png' },
      { char: 'ã„', strokeImg: 'https://raw.githubusercontent.com/nihow79207-wang/japanese-assets/main/ã„.png' },
      { char: 'ã†', strokeImg: 'https://raw.githubusercontent.com/nihow79207-wang/japanese-assets/main/ã†.png' },
      { char: 'ãˆ', strokeImg: 'https://raw.githubusercontent.com/nihow79207-wang/japanese-assets/main/ãˆ.png' },
      { char: 'ãŠ', strokeImg: 'https://raw.githubusercontent.com/nihow79207-wang/japanese-assets/main/ãŠ.png' }
    ];

    const FRUIT_A = [
      { id: 'apple', word: 'ã‚Šã‚“ã”', emoji: 'ğŸ', meaning: 'è˜‹æœ' },
      { id: 'grape', word: 'ã¶ã©ã†', emoji: 'ğŸ‡', meaning: 'è‘¡è„' },
      { id: 'melon', word: 'ãƒ¡ãƒ­ãƒ³', emoji: 'ğŸˆ', meaning: 'å“ˆå¯†ç“œ' },
      { id: 'orange', word: 'ã¿ã‹ã‚“', emoji: 'ğŸŠ', meaning: 'æ©˜å­' },
      { id: 'watermelon', word: 'ã™ã„ã‹', emoji: 'ğŸ‰', meaning: 'è¥¿ç“œ' }
    ];

    const FRUIT_B = [
      { id: 'pineapple', word: 'ãƒ‘ã‚¤ãƒŠãƒƒãƒ—ãƒ«', emoji: 'ğŸ', meaning: 'é³³æ¢¨' },
      { id: 'strawberry', word: 'ã„ã¡ã”', emoji: 'ğŸ“', meaning: 'è‰è“' },
      { id: 'kiwi', word: 'ã‚­ã‚¦ã‚¤', emoji: 'ğŸ¥', meaning: 'å¥‡ç•°æœ' },
      { id: 'lemon', word: 'ãƒ¬ãƒ¢ãƒ³', emoji: 'ğŸ‹', meaning: 'æª¸æª¬' },
      { id: 'banana', word: 'ãƒãƒŠãƒŠ', emoji: 'ğŸŒ', meaning: 'é¦™è•‰' }
    ];

    let audioContext = null;

    const playTTS = async (text) => {
      const ut = new SpeechSynthesisUtterance(text);
      ut.lang = 'ja-JP'; ut.rate = 0.9;
      window.speechSynthesis.speak(ut);

      if (process.env.API_KEY) {
        try {
          const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
          const response = await ai.models.generateContent({
            model: "gemini-2.5-flash-preview-tts",
            contents: `Say '${text}'`,
            config: {
              responseModalities: [Modality.AUDIO],
              speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: 'Kore' } } }
            }
          });
          const base64 = response.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
          if (base64) {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            const buffer = await audioContext.decodeAudioData(bytes.buffer);
            const source = audioContext.createBufferSource();
            source.buffer = buffer; source.connect(audioContext.destination); source.start(0);
          }
        } catch (e) { console.warn("Gemini TTS skip", e); }
      }
    };

    const verifyHandwriting = async (base64Image, target) => {
      if (!process.env.API_KEY) return { isCorrect: true, feedback: "å¯«å¾—çœŸæ£’ï¼" };
      const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
      const response = await ai.models.generateContent({
        model: "gemini-3-flash-preview",
        contents: {
          parts: [
            { text: `Is this handwritten Japanese character '${target}'? Return JSON ONLY.` },
            { inlineData: { data: base64Image.split(',')[1], mimeType: 'image/png' } }
          ]
        },
        config: { 
          responseMimeType: "application/json",
          responseSchema: {
            type: Type.OBJECT,
            properties: {
              isCorrect: { type: Type.BOOLEAN },
              feedback: { type: Type.STRING, description: "Short encouragement in Traditional Chinese" }
            },
            required: ["isCorrect", "feedback"]
          }
        }
      });
      return JSON.parse(response.text);
    };

    const verifyPronunciation = async (audioBase64, target) => {
      if (!process.env.API_KEY) return { isCorrect: true, feedback: "ç™¼éŸ³æ­£ç¢ºï¼" };
      const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
      const response = await ai.models.generateContent({
        model: "gemini-3-flash-preview",
        contents: {
          parts: [
            { text: `Analyze the user's audio for the Japanese word '${target}'. Correct? Return JSON ONLY.` },
            { inlineData: { data: audioBase64, mimeType: 'audio/webm' } }
          ]
        },
        config: { 
          responseMimeType: "application/json",
          responseSchema: {
            type: Type.OBJECT,
            properties: {
              isCorrect: { type: Type.BOOLEAN },
              feedback: { type: Type.STRING, description: "Short encouragement in Traditional Chinese" }
            },
            required: ["isCorrect", "feedback"]
          }
        }
      });
      return JSON.parse(response.text);
    };

    // --- å…ƒä»¶ï¼šè¼‰å…¥è¨Šæ¯ ---
    const LoadingOverlay = ({ messages }) => {
      const [msgIdx, setMsgIdx] = useState(0);
      useEffect(() => {
        const timer = setInterval(() => setMsgIdx(p => (p + 1) % messages.length), 1500);
        return () => clearInterval(timer);
      }, [messages]);

      return (
        <div className="absolute inset-0 bg-white/80 backdrop-blur-sm flex flex-col items-center justify-center p-6 z-20 rounded-2xl">
          <div className="relative mb-6">
            <div className="w-20 h-20 border-8 border-sky-100 border-t-sky-500 rounded-full animate-spin"></div>
            <div className="absolute inset-0 flex items-center justify-center text-3xl animate-wiggle">ğŸ§</div>
          </div>
          <p className="text-xl font-black text-sky-600 animate-pulse text-center">{messages[msgIdx]}</p>
        </div>
      );
    };

    // --- å…ƒä»¶ï¼šç•«æ¿ ---
    const CanvasBoard = ({ targetChar, onClear, onSubmit, isVerifying }) => {
      const canvasRef = useRef(null);
      const [isDrawing, setIsDrawing] = useState(false);
      const [hasDrawn, setHasDrawn] = useState(false);

      useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#f1f5f9'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
        ctx.beginPath(); ctx.moveTo(200, 0); ctx.lineTo(200, 400); ctx.moveTo(0, 200); ctx.lineTo(400, 200); ctx.stroke();
        ctx.setLineDash([]); ctx.strokeStyle = '#0284c7'; ctx.lineWidth = 15; ctx.lineCap = 'round';
        setHasDrawn(false);
      }, [targetChar]);

      const getPos = (e) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: (clientX - rect.left) * (400 / rect.width), y: (clientY - rect.top) * (400 / rect.height) };
      };

      const startDrawing = (e) => {
        if (isVerifying) return;
        setIsDrawing(true); setHasDrawn(true);
        const { x, y } = getPos(e);
        const ctx = canvasRef.current.getContext('2d');
        ctx.beginPath(); ctx.moveTo(x, y);
      };

      const draw = (e) => {
        if (!isDrawing || isVerifying) return;
        const { x, y } = getPos(e);
        const ctx = canvasRef.current.getContext('2d');
        ctx.lineTo(x, y); ctx.stroke();
      };

      return (
        <div className="flex flex-col items-center gap-4">
          <div className="relative bg-white p-2 rounded-3xl shadow-2xl border-4 border-sky-100 overflow-hidden">
            <canvas ref={canvasRef} width={400} height={400} className="pencil-cursor touch-none w-full max-w-[400px]"
              onMouseDown={startDrawing} onMouseMove={draw} onMouseUp={() => setIsDrawing(false)}
              onTouchStart={startDrawing} onTouchMove={draw} onTouchEnd={() => setIsDrawing(false)}
            />
            {isVerifying && <LoadingOverlay messages={LOADING_MESSAGES} />}
          </div>
          <div className="flex gap-4">
            <button onClick={() => { onClear(); const ctx = canvasRef.current.getContext('2d'); ctx.fillStyle='white'; ctx.fillRect(0,0,400,400); setHasDrawn(false); }} className="px-8 py-3 bg-gray-200 rounded-full font-bold">æ¸…é™¤</button>
            <button onClick={() => hasDrawn && onSubmit(canvasRef.current.toDataURL())} className="px-12 py-3 bg-sky-500 text-white rounded-full font-bold shadow-lg disabled:bg-gray-400">é€å‡º</button>
          </div>
        </div>
      );
    };

    const JapaneseLearningGame = () => {
      const [screen, setScreen] = useState('home');
      const [coins, setCoins] = useState(0);
      const [charStates, setCharStates] = useState({});
      const [gameTargets, setGameTargets] = useState([]);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [feedback, setFeedback] = useState(null);
      const [isVerifying, setIsVerifying] = useState(false);
      const [isRecording, setIsRecording] = useState(false);
      const recorderRef = useRef(null);

      // é è¼‰åŠŸèƒ½
      const preloadNextTTS = (idx) => {
        if (idx + 1 < gameTargets.length) {
          const next = gameTargets[idx+1];
          // é›–ç„¶åŸ playTTS æœƒæ’­æ”¾ï¼Œä½†åœ¨é€™è£¡æˆ‘å€‘å¯ä»¥åªåšéœé»˜é è¼‰(è‹¥æœ‰å¿«å–æ©Ÿåˆ¶)
          // é€™è£¡æ¨¡æ“¬è§¸ç™¼ç€è¦½å™¨åˆæˆå™¨ä½†ä¸ç™¼è²ä»¥ç†±èº«ï¼Œæˆ–åƒ…æº–å‚™ API è«‹æ±‚
        }
      };

      const startHiragana = () => {
        const initial = {}; HIRAGANA_A_COLUMN.forEach(c => initial[c.char] = 'normal');
        setCharStates(initial); setScreen('learning');
      };

      const handleCharClick = (char) => {
        const s = charStates[char]; if (s === 'done') return;
        playTTS(char);
        if (s === 'normal') setCharStates(p => ({...p, [char]: 'flipped'}));
        else setCharStates(p => ({...p, [char]: 'done'}));
      };

      useEffect(() => {
        if (screen === 'learning' && HIRAGANA_A_COLUMN.every(c => charStates[c.char] === 'done')) {
          setTimeout(() => {
            const shuffled = [...HIRAGANA_A_COLUMN].sort(() => Math.random() - 0.5);
            setGameTargets(shuffled); setCurrentIndex(0); setScreen('game1');
            playTTS(shuffled[0].char);
          }, 800);
        }
      }, [charStates, screen]);

      const startVocab = (set) => {
        setGameTargets(set);
        const initial = {}; set.forEach(v => initial[v.id] = 'normal');
        setCharStates(initial); setScreen('vocab_learning');
      };

      const handleVocabClick = (v) => {
        const s = charStates[v.id]; if (s === 'done') return;
        playTTS(v.word);
        if (s === 'normal') setCharStates(p => ({...p, [v.id]: 'flipped'}));
        else setCharStates(p => ({...p, [v.id]: 'done'}));
      };

      useEffect(() => {
        if (screen === 'vocab_learning' && gameTargets.length > 0 && gameTargets.every(v => charStates[v.id] === 'done')) {
          setTimeout(() => {
            setScreen('vocab_game1'); setCurrentIndex(0);
            playTTS(gameTargets[0].word);
          }, 800);
        }
      }, [charStates, screen]);

      const handleSelect = (val, isChar = true) => {
        const target = isChar ? gameTargets[currentIndex].char : gameTargets[currentIndex].id;
        if (val === target) {
          playTTS('æ­£è§£ï¼'); setFeedback('correct');
          setTimeout(() => {
            setFeedback(null);
            if (currentIndex + 1 < gameTargets.length) {
              const nextIdx = currentIndex + 1;
              setCurrentIndex(nextIdx);
              playTTS(isChar ? gameTargets[nextIdx].char : gameTargets[nextIdx].word);
            } else {
              setScreen(isChar ? 'game2' : 'vocab_game2');
              setCurrentIndex(0);
              playTTS(isChar ? gameTargets[0].char : gameTargets[0].word);
            }
          }, 1000);
        } else {
          playTTS('æ®‹å¿µ'); setFeedback('wrong');
          setTimeout(() => setFeedback(null), 800);
        }
      };

      const toggleRecording = async () => {
        if (isRecording) {
          recorderRef.current.stop(); setIsRecording(false);
        } else {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const recorder = new MediaRecorder(stream);
            const chunks = [];
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = async () => {
              const blob = new Blob(chunks, { type: 'audio/webm' });
              const reader = new FileReader();
              reader.onloadend = async () => {
                setIsVerifying(true);
                const res = await verifyPronunciation(reader.result.split(',')[1], gameTargets[currentIndex].word);
                setIsVerifying(false);
                if (res.isCorrect) {
                  setFeedback({ text: res.feedback, type: 'success' }); playTTS('ç´ æ™´ã‚‰ã—ã„');
                  setTimeout(() => {
                    setFeedback(null);
                    if (currentIndex + 1 < gameTargets.length) {
                      setCurrentIndex(i => i + 1); preloadNextTTS(currentIndex);
                    } else {
                      setCoins(c => { const nc = c + 1; setScreen(nc >= 2 ? 'story' : 'vocab_story'); return nc; });
                    }
                  }, 2500);
                } else { setFeedback({ text: res.feedback, type: 'error' }); playTTS('æƒœã—ã„'); }
              };
              reader.readAsDataURL(blob);
            };
            recorder.start(); recorderRef.current = recorder; setIsRecording(true);
          } catch (e) { alert("éº¥å…‹é¢¨è¢«å°å°äº†ï¼è«‹è§£é–‹æ¬Šé™å–”ï¼"); }
        }
      };

      return (
        <div className="min-h-screen flex flex-col items-center justify-center p-4">
          {screen !== 'home' && (
            <div className="fixed top-0 w-full p-4 flex justify-between z-50">
              <button onClick={() => { setScreen('home'); setFeedback(null); }} className="w-12 h-12 bg-yellow-400 rounded-full flex items-center justify-center text-white text-2xl shadow-lg hover:scale-110 transition">ğŸ </button>
              <div className="bg-white/90 px-6 py-2 rounded-full border-2 border-amber-200 shadow-md flex items-center gap-2">
                <span className="text-xl">ğŸ’°</span><span className="text-xl font-black text-amber-600">{coins}</span>
              </div>
            </div>
          )}

          {screen === 'home' && (
            <div className="text-center animate-scale-up">
              <h1 className="text-7xl md:text-8xl font-black text-sky-500 mb-4 rounded-font drop-shadow-lg">æ—¥æ–‡ä¸€èµ·å­¸</h1>
              <p className="text-2xl text-amber-600 mb-12 font-bold italic">Happy Learning Adventure!</p>
              <button onClick={() => setScreen('instructions')} className="px-16 py-8 bg-yellow-400 text-white text-4xl font-bold rounded-full shadow-[0_10px_0_#d97706] active:translate-y-[10px] transition-all">é–‹å§‹å†’éšª</button>
            </div>
          )}

          {screen === 'instructions' && (
            <div className="max-w-2xl bg-white p-12 rounded-[3.5rem] shadow-2xl border-8 border-yellow-200 text-center animate-scale-up">
              <h2 className="text-4xl font-bold text-sky-500 mb-8">å†’éšªæŒ‡å—</h2>
              <div className="space-y-4 text-2xl font-bold text-amber-800 text-left">
                <p>â­ å­¸ç¿’å­—æ¯èˆ‡å–®å­—ï¼Œå¤§è²å”¸å‡ºä¾†</p>
                <p>ğŸ’° å®ŒæˆæŒ‘æˆ°å¯ç²å¾—é‡‘å¹£</p>
                <p>ğŸŒŸ ç´¯ç© 2 æšé‡‘å¹£è§£é–å‚³èªªæ•…äº‹</p>
              </div>
              <button onClick={() => setScreen('menu')} className="mt-10 px-16 py-4 bg-sky-500 text-white text-3xl rounded-full shadow-lg hover:bg-sky-600">æº–å‚™å¥½äº†ï¼</button>
            </div>
          )}

          {screen === 'menu' && (
            <div className="w-full max-w-5xl text-center animate-scale-up">
              <h2 className="text-5xl font-black text-sky-600 mb-16 rounded-font">å†’éšªä»»å‹™åœ°åœ–</h2>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-12 px-4">
                <button onClick={startHiragana} className="bg-white p-12 rounded-[4rem] shadow-2xl border-4 border-sky-100 hover:scale-105 transition group">
                  <div className="text-9xl mb-8 group-hover:animate-bounce-subtle">ã‚</div>
                  <span className="text-4xl font-black text-sky-500">äº”åéŸ³åŸºç¤</span>
                </button>
                <button onClick={() => setScreen('vocab_menu')} className="bg-white p-12 rounded-[4rem] shadow-2xl border-4 border-teal-100 hover:scale-105 transition group">
                  <div className="text-9xl mb-8 group-hover:animate-bounce-subtle">ğŸ</div>
                  <span className="text-4xl font-black text-teal-500">å–®å­—æ¢éšªéšŠ</span>
                </button>
              </div>
            </div>
          )}

          {screen === 'learning' && (
            <div className="flex flex-col items-center animate-scale-up">
              <h2 className="text-4xl font-black text-sky-600 mb-12 bg-white px-8 py-4 rounded-full shadow-md">å­¸ç¿’ï¼šã‚è¡Œ</h2>
              <div className="flex flex-wrap justify-center gap-10">
                {HIRAGANA_A_COLUMN.map(c => (
                  <div key={c.char} onClick={() => handleCharClick(c.char)} className={`perspective-1000 w-48 h-48 cursor-pointer ${charStates[c.char] === 'done' ? 'animate-shrink' : ''}`}>
                    <div className={`relative w-full h-full preserve-3d transition-all duration-500 ${charStates[c.char] !== 'normal' ? 'rotate-y-180' : ''}`}>
                      <div className="absolute inset-0 backface-hidden flex items-center justify-center bg-sky-400 text-white text-9xl font-bold rounded-full border-8 border-sky-300">{c.char}</div>
                      <div className="absolute inset-0 backface-hidden rotate-y-180 flex items-center justify-center bg-white rounded-full border-8 border-pink-300 p-6"><img src={c.strokeImg} className="w-full h-full object-contain" /></div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {screen === 'game1' && (
            <div className="text-center animate-scale-up">
              <div className="bg-sky-500 text-white px-10 py-4 rounded-full text-3xl font-black mb-12 shadow-lg inline-block">è½éŸ³é¸å­— ({currentIndex + 1}/5)</div>
              <button onClick={() => playTTS(gameTargets[currentIndex].char)} className="w-32 h-32 bg-sky-400 rounded-full flex items-center justify-center shadow-2xl mx-auto mb-16 animate-pulse text-6xl text-white">ğŸ”Š</button>
              <div className="flex flex-wrap justify-center gap-6">
                {HIRAGANA_A_COLUMN.map(c => (
                  <button key={c.char} onClick={() => handleSelect(c.char)} className={`w-32 h-32 rounded-full text-5xl font-bold border-4 transition-all shadow-xl ${feedback === 'correct' && c.char === gameTargets[currentIndex].char ? 'bg-green-500 text-white border-green-200' : 'bg-white text-sky-500 border-sky-100 hover:bg-sky-50'}`}>{c.char}</button>
                ))}
              </div>
            </div>
          )}

          {screen === 'game2' && (
            <div className="animate-scale-up text-center w-full max-w-lg">
              <div className="bg-purple-500 text-white px-10 py-4 rounded-full text-3xl font-black mb-8">å¯«å­—ç·´ç¿’ ({currentIndex+1}/5)</div>
              <div className="mb-4 flex items-center justify-center gap-6">
                <span className="text-9xl font-black text-gray-200/50 select-none">{gameTargets[currentIndex].char}</span>
              </div>
              <CanvasBoard targetChar={gameTargets[currentIndex].char} onClear={() => setFeedback(null)} isVerifying={isVerifying} onSubmit={async (img) => {
                setIsVerifying(true); const res = await verifyHandwriting(img, gameTargets[currentIndex].char); setIsVerifying(false);
                if (res.isCorrect) {
                  setFeedback({ text: res.feedback, type: 'success' }); playTTS('ç´ æ™´ã‚‰ã—ã„');
                  setTimeout(() => {
                    setFeedback(null);
                    if (currentIndex+1 < gameTargets.length) { setCurrentIndex(i => i + 1); preloadNextTTS(currentIndex); }
                    else setCoins(c => { const nc = c+1; setScreen(nc >= 2 ? 'story' : 'menu'); return nc; });
                  }, 2000);
                } else { setFeedback({ text: res.feedback, type: 'error' }); playTTS('æƒœã—ã„'); }
              }} />
              {feedback && <div className={`mt-6 px-8 py-3 rounded-2xl text-2xl font-bold shadow-md ${feedback.type === 'success' ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>{feedback.text}</div>}
            </div>
          )}

          {screen === 'vocab_menu' && (
            <div className="text-center animate-scale-up w-full max-w-4xl">
              <h2 className="text-7xl font-black text-teal-600 mb-12">å–®å­—å¤§å†’éšª</h2>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-10">
                <button onClick={() => startVocab(FRUIT_A)} className="bg-white p-10 rounded-[3.5rem] shadow-xl border-8 border-white flex gap-6 hover:scale-105 transition items-center">
                  <div className="text-8xl">ğŸ</div><div className="text-left font-black text-4xl text-teal-700">æ°´æœ A çµ„<div className="text-xl text-gray-400">è˜‹æœ, è‘¡è„...</div></div>
                </button>
                <button onClick={() => startVocab(FRUIT_B)} className="bg-white p-10 rounded-[3.5rem] shadow-xl border-8 border-white flex gap-6 hover:scale-105 transition items-center">
                  <div className="text-8xl">ğŸ</div><div className="text-left font-black text-4xl text-teal-700">æ°´æœ B çµ„<div className="text-xl text-gray-400">é³³æ¢¨, é¦™è•‰...</div></div>
                </button>
              </div>
            </div>
          )}

          {screen === 'vocab_learning' && (
            <div className="animate-scale-up text-center">
              <h2 className="text-4xl font-black text-teal-600 mb-12">æ°´æœé»é»å</h2>
              <div className="flex flex-wrap justify-center gap-10">
                {gameTargets.map(v => (
                  <div key={v.id} onClick={() => handleVocabClick(v)} className={`perspective-1000 w-56 h-56 cursor-pointer ${charStates[v.id] === 'done' ? 'animate-shrink' : ''}`}>
                    <div className={`relative w-full h-full preserve-3d transition-all duration-700 ${charStates[v.id] !== 'normal' ? 'rotate-y-180' : ''}`}>
                      <div className="absolute inset-0 backface-hidden flex items-center justify-center bg-white rounded-full border-8 border-teal-50 shadow-xl text-[10rem]">{v.emoji}</div>
                      <div className="absolute inset-0 backface-hidden rotate-y-180 flex flex-col items-center justify-center bg-teal-50 rounded-full border-8 border-teal-300 shadow-xl">
                        <span className="text-9xl">{v.emoji}</span><span className="text-4xl font-black text-teal-700">{v.word}</span>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {screen === 'vocab_game1' && (
            <div className="text-center animate-scale-up">
              <div className="bg-teal-500 text-white px-10 py-4 rounded-full text-3xl font-black mb-12 shadow-lg inline-block">è½éŸ³é¸åœ– ({currentIndex + 1}/5)</div>
              <button onClick={() => playTTS(gameTargets[currentIndex].word)} className="w-32 h-32 bg-sky-400 rounded-full flex items-center justify-center shadow-2xl mx-auto mb-16 animate-pulse text-6xl text-white">ğŸ”Š</button>
              <div className="flex flex-wrap justify-center gap-8">
                {gameTargets.map(v => (
                  <button key={v.id} onClick={() => handleSelect(v.id, false)} className={`w-44 h-44 rounded-[2.5rem] bg-white text-9xl flex items-center justify-center border-8 transition-all shadow-xl ${feedback === 'correct' && v.id === gameTargets[currentIndex].id ? 'border-green-500 scale-110' : 'border-white hover:border-teal-300'}`}>{v.emoji}</button>
                ))}
              </div>
            </div>
          )}

          {screen === 'vocab_game2' && (
            <div className="text-center animate-scale-up w-full max-w-2xl">
              <div className="bg-indigo-500 text-white px-10 py-4 rounded-full text-3xl font-black mb-12 shadow-lg inline-block">çœ‹åœ–å¿µå­—æŒ‘æˆ°</div>
              <div className="relative bg-white p-12 rounded-[4rem] shadow-2xl border-8 border-indigo-100 flex flex-col items-center gap-8">
                {isVerifying && <LoadingOverlay messages={LOADING_MESSAGES} />}
                <span className="text-[12rem] leading-none drop-shadow-md select-none">{gameTargets[currentIndex].emoji}</span>
                <p className="text-7xl font-black text-indigo-600 select-none">{gameTargets[currentIndex].word}</p>
                <div className="flex flex-col items-center gap-4">
                  <button onMouseDown={toggleRecording} onTouchStart={toggleRecording} onMouseUp={toggleRecording} onTouchEnd={toggleRecording} 
                    className={`w-32 h-32 rounded-full flex items-center justify-center text-5xl text-white shadow-2xl transition-all ${isRecording ? 'bg-red-500 animate-ping' : 'bg-indigo-500 active:scale-90 hover:scale-105'} z-10`}>
                    {isRecording ? 'â¹ï¸' : 'ğŸ¤'}
                  </button>
                  <p className="text-xl text-gray-400 font-bold">{isRecording ? 'éŒ„éŸ³ä¸­...' : 'æŒ‰ä½éº¥å…‹é¢¨ä¸¦å¤§è²å”¸å‡ºä¾†'}</p>
                </div>
                {feedback && <div className={`px-10 py-5 rounded-3xl text-3xl font-black shadow-lg ${feedback.type === 'success' ? 'bg-green-100 text-green-700 border-4 border-green-200' : 'bg-red-100 text-red-700 border-4 border-red-200'}`}>{feedback.text}</div>}
              </div>
            </div>
          )}

          {screen === 'vocab_story' && (
            <div className="w-full max-w-4xl bg-white p-16 rounded-[4.5rem] shadow-2xl border-y-[12px] border-teal-400 animate-scale-up text-center">
              <div className="text-9xl mb-8 animate-bounce-subtle">ğŸ“</div>
              <h2 className="text-5xl font-black text-teal-600 mb-8 leading-tight">å–®å…ƒçå‹µï¼šé³¥å±…ç§˜è¾›</h2>
              <div className="space-y-6 text-2xl text-gray-700 font-bold leading-relaxed">
                <p>æ—¥æœ¬ç¥ç¤¾é–€å£çš„ã€Œé³¥å±…ã€ï¼Œå…¶å¯¦æ˜¯ç‚ºäº†çµ¦<span className="text-pink-500 text-4xl mx-2">ã€Œé›ã€</span>ç«™çš„å–”ï¼ğŸ“</p>
                <div className="bg-teal-50 p-8 rounded-[2.5rem] border-l-8 border-teal-300 text-left">
                  å¤æ™‚å€™çœ¾ç¥æƒ³æŠŠèº²èµ·ä¾†çš„å¤ªé™½å¥³ç¥å«å‡ºä¾†ï¼Œå°±è®“å…¬é›åœ¨æ¶å­ä¸Šä¸åœåœ°å«ã€‚é€™å°±æ˜¯ã€Œé³¥å±…ã€æœ€æ—©çš„ç”±ä¾†ï¼
                </div>
              </div>
              <button onClick={() => setScreen('menu')} className="mt-12 w-full py-6 bg-teal-500 text-white text-3xl font-black rounded-full shadow-lg">å†å»æŒ‘æˆ°ä¸‹ä¸€å€‹ä»»å‹™å§ï¼</button>
            </div>
          )}

          {screen === 'story' && (
            <div className="w-full max-w-4xl bg-white p-16 rounded-[5rem] shadow-2xl border-x-[16px] border-yellow-300 animate-scale-up text-center relative">
              <div className="text-[10rem] mb-8 animate-bounce-subtle">ğŸŒŸ</div>
              <h2 className="text-6xl font-black text-amber-600 mb-12 leading-tight">ç©¶æ¥µçå‹µæ•…äº‹ï¼š<br/>æ¨¹å‹¾è¡£é¤’ï¼</h2>
              <div className="space-y-10 text-3xl text-gray-700 font-bold leading-loose">
                <p>æœ‰ä¸€å¤©å°æ˜è·Ÿæœ‹å‹å»æ¨¹ä¸‹é‡é¤ï¼Œè¡£æœä¸å°å¿ƒè¢«æ¨¹æå‹¾ä½äº†...</p>
                <p>ä»–æŒ‡è‘—å‹¾ä½çš„åœ°æ–¹ï¼Œè·Ÿæœ‹å‹å¤§è²é©šå‘¼ï¼š</p>
                <p className="text-7xl font-black text-sky-500 py-10 bg-sky-50 rounded-[3rem] tracking-widest shadow-inner">ã€Œ æ¨¹ å‹¾ è¡£ é¤’ ï¼ ã€</p>
                <div className="text-2xl text-amber-400 font-black italic">( ã™ã”ã„ã­ - Sugoi ne! æ—¥æœ¬èªï¼šå¤ªå²å®³äº†ï¼ )</div>
                <p className="text-amber-600 text-4xl">æ­å–œä½ å®Œæˆæ‰€æœ‰å†’éšªï¼ä½ çœŸçš„å¤ªã€Œæ¨¹å‹¾è¡£é¤’ã€äº†ï¼</p>
              </div>
              <button onClick={() => { setScreen('home'); setCoins(0); }} className="mt-16 w-full py-8 bg-amber-500 text-white text-4xl font-black rounded-full shadow-[0_12px_0_#d97706] active:translate-y-2">é‡æ–°é–‹å§‹å¤§å†’éšª</button>
            </div>
          )}
        </div>
      );
    };

    const root = createRoot(document.getElementById('root'));
    root.render(<JapaneseLearningGame />);
  </script>
</body>
</html>

